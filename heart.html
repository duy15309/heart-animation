<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Heart Animation</title>
  <style>
    body, html { margin: 0; padding: 0; background: black; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let WIDTH, HEIGHT;
    function resize() {
      WIDTH = canvas.width = window.innerWidth;
      HEIGHT = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Cấu hình
    const FPS = 60;
    const HEART_SCALE = Math.min(WIDTH, HEIGHT) / 50;
    const THROB_MIN = 0.9, THROB_MAX = 1.1;
    const THROB_SPEED = 0.005;
    const PARTICLE_SPAWN_RATE = 4;
    const MAX_PARTICLES = 300;
    const DELAY_FRAMES = Math.floor(0.25 * FPS);

    // Tạo points trái tim parametric
    function makeHeartPoints(n=200) {
      const pts = [];
      for (let i=0; i<n; i++) {
        const t = 2 * Math.PI * i / n;
        const x = 16 * Math.pow(Math.sin(t),3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
        pts.push({x, y: -y});
      }
      return pts;
    }
    const heartPts = makeHeartPoints(300);

    // Particle class
    class Particle {
      constructor(x,y,dir) {
        this.x = x;
        this.y = y;
        this.vx = dir.x * (Math.random()*2 + 1);
        this.vy = dir.y * (Math.random()*2 + 1);
        this.life = Math.random() * 1.5 + 1;
        this.maxLife = this.life;
        this.size = Math.random()*2 + 1;
      }
      update(dt) {
        this.x += this.vx * dt * FPS;
        this.y += this.vy * dt * FPS;
        this.life -= dt;
      }
      draw(ctx) {
        const alpha = Math.max(0, this.life/this.maxLife);
        ctx.fillStyle = `rgba(255,150,200,${alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 2*Math.PI);
        ctx.fill();
      }
    }

    let particles = [];
    let scale = 1, throbDir = 1;
    const scaleHistory = [];

    function spawn(scale) {
      for (let i=0; i<PARTICLE_SPAWN_RATE; i++) {
        const idx = Math.floor(Math.random()*heartPts.length);
        const p = heartPts[idx];
        const x = WIDTH/2 + p.x * HEART_SCALE * scale;
        const y = HEIGHT/2 + p.y * HEART_SCALE * scale;
        // outward
        const dx = x - WIDTH/2, dy = y - HEIGHT/2;
        const len = Math.hypot(dx,dy) || 1;
        particles.push(new Particle(x,y,{x:dx/len, y:dy/len}));
      }
    }

    function drawHeart(ctx, scale, color='rgb(255,100,180)', width=2) {
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      heartPts.forEach((p,i) => {
        const x = WIDTH/2 + p.x * HEART_SCALE * scale;
        const y = HEIGHT/2 + p.y * HEART_SCALE * scale;
        if (i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      });
      ctx.closePath();
      ctx.stroke();
    }

    function loop() {
      const dt = 1/FPS;
      // throb
      scale += throbDir * THROB_SPEED;
      if (scale>THROB_MAX||scale<THROB_MIN) throbDir*=-1;
      scaleHistory.push(scale);
      let delayedScale = scaleHistory.length>DELAY_FRAMES ? scaleHistory.shift() : scale;

      spawn(scale);
      if (particles.length>MAX_PARTICLES) particles.splice(0, particles.length-MAX_PARTICLES);
      particles.forEach(p=>p.update(dt));
      particles = particles.filter(p=>p.life>0);

      // vẽ
      ctx.clearRect(0,0,WIDTH,HEIGHT);
      drawHeart(ctx, delayedScale, 'rgba(200,200,200,0.8)');
      drawHeart(ctx, scale);
      // draw chars
      const fs = 80*scale;
      ctx.font = `${fs}px sans-serif`;
      ctx.fillStyle = 'rgb(255,100,180)';
      const offset = 70*scale;
      ctx.fillText('N', WIDTH/2 - offset, HEIGHT/2 + fs/3);
      ctx.fillText('D', WIDTH/2 + offset - fs/4, HEIGHT/2 + fs/3);

      particles.forEach(p=>p.draw(ctx));
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
